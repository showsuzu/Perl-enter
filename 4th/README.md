## サブルーチン
### 定義
 - subと書く

    `sub say { ... };`

### 引数
 - 他の言語と比べると、かなり奇妙
 - 配列、@_ に左から順に入るらしい。
 - 配列なので、取り出すのはshift等を使用する
 - 一つづつ取り出す例（@_は省略してもOKらしい）
        
        my $left  = shift;
        my $right = shift;


 - まとめて取り出す例

    `my ($left, $right) = @_;`

 - 引数に配列やハッシュを指定する場合
  - 直接配列やハッシュを指定してしまうと、受け取り側で他の引数との区切りがわからないので、配列やハッシュとして受け取れない。
  - リファレンスを使用する。リファレンスの扱いに慣れていないと辛い

        my @hoge = qw/ hoge fuga /;
        my @foo  = qw/ foo bar baz /;
        # 配列を定義し
        output(\@hoge, \@foo);
        # 2つの配列を引数に指定する。その時リファレンスとして指定する
        sub output {
                # 受け取る時は、スカラ変数
                my ($array1, $array2) = @_;
                #配列なので、@を付けてデリファレンスして使用する
                print '@$array1 = ' . join(',', @$array1) . "\n";
                print '@$array2 = ' . join(',', @$array2) . "\n";
        };

### 返り値
 - 複数の返り値が返せる。
 - その場合も、配列で受け取るような記述
        
        sub calc {
                my ($left, $right) = @_;
                return ($left + $right, $left - $right);
        }
        my ($add, $min) = calc(5, 4);

___
## 正規表現
 - さまざまな文字列等のパターンマッチができる
 - 使えるようになると、かなりの武器になる。
 - ちなみにlove_food.plの練習問題時、文末に"!"がない場合もマッチさせようとすると、以下のように書ける

        `/(.+?) loves (.+)!?/;`

 - でも、上の式だと、文末に"!"がある場合、そのまま!が出力されてしまう。

        `/(.+?) loves ([^!]+)!?/;`
 - 上のようにする事で、!を含まない文字をグループ化して、最後の!が、?に食われてしまうのを防止する必要があるようだ。
 - 正規表現は深い。

___
## 演習問題
 - 1.score.pl
  - リファレンスの復習（平均値の算出は、問題を読み違えて5言語分の平均をとっている）

 - 2.subroutine.pl
  - 2つの引数の和を計算するadd, 2つの引数の差を計算するmin, 積を計算するmul, 商を計算するdivというサブルーチンを作る
  - これらのサブルーチンが正しく実装できているかを確認する

 - 3.output_array_and_hash.pl
  - 配列とハッシュをそれぞれ1つずつ定義してから, 第1引数に配列のリファレンス, 第2引数にハッシュのリファレンスを受け取り, その中身を出力するoutput_array_and_hashというサブルーチンを書いてみよう.

 - 4.perl_checker.pl
  - 引数として文字列を受け取り, その文字列にperlないしPerlが含まれるなら｢Perl Monger!｣と表示するサブルーチンperl_checkerを書いてみましょう.

 - 5.love_food.pl
  - 配列のリファレンスを受け取り, リファレンスに格納された文字列について, ｢loves｣の後に記述されている好きな食べ物の単語を正規表現で取得し, ｢papix -> meat｣, ｢boolfool -> sushi｣のように表示するサブルーチン, love_foodを書いてみよう.

 - 6.iloveperl.pl
  - $strに格納された文字列を 置換を利用して, ｢I love perl｣に書き換えるようなコードを書いてみましょう.

 - 7.regexpr.pl
  - while (chomp(my $input = <STDIN>))を使用して、以下の処理を行う
   - 文字列が0の場合, ループを抜ける(lastを使って...).
   - 文字列がperlないしPerlを含む場合, ｢Find Perl!｣と表示する.
   - 文字列に大文字小文字問わず, pythonの文字列が含まれる場合, ｢Find Python!｣と表示する.
   - 文字列にperlないしrubyないしpythonが含まれる場合, ｢Love Programming!｣と表示する.
